use serde::{Serialize, Deserialize};
use crate::core::Role;

/// Chat message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Message {

    /// The role of the messages author.
    pub role: Option<Role>,

    /// The contents of the message.
    pub content: Option<Content>,

    /// Tool call that this message is responding to.
    ///
    /// Specify only when `role` is `Tool`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_call_id: Option<String>,

    /// The refusal message by the assistant.
    ///
    /// Only specified when `assistant` responses refuse a prompt.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub refusal: Option<String>,

    /// The tool calls generated by the model, such as function calls.
    ///
    /// Only specified in `assistant` responses that use tool calls.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_calls: Option<Vec<ToolCall>>,
}

/// Describes the possible response types of a [Message].
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Content {
    Text(String),
    Content(Vec<ContentData>),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ContentKind {
    InputText,
    InputFile,
    Text,
    ImageUrl,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContentData {

    #[serde(rename = "type")]
    pub kind: String,

    /// A basic text response.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,

    /// URL to an image to be embedded as context.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub image_url: Option<String>,

    /// URL to an file/document to be embedded as context.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file_url: Option<String>,

    /// Name of the file whose data is being uploaded. Associated file
    /// data is sent as a base64 in the [Self::file_data] field.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub filename: Option<String>,

    /// Base64 encoded file data to add as context.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file_data: Option<String>,
}

/// Tool Definition.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolDefinition {

    /// The type of the tool. Currently, only `function` is supported.
    #[serde(rename = "type")]
    pub kind: String,

    /// Tool function definition.
    pub function: FunctionDefinition,
}

/// Function Definition.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FunctionDefinition {

    /// The name of the function to be called. Must be a-z, A-Z, 0-9,
    /// or contain underscores and dashes, with a maximum length of
    /// 64.
    pub name: String,

    /// A description of what the function does, used by the model to
    /// choose when and how to call the function.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    /// The parameters the functions accepts.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parameters: Option<serde_json::Value>,

    /// Whether to enable strict schema adherence when generating the
    /// function call. If set to true, the model will follow the exact
    /// schema defined in the `parameters` field.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub strict: Option<bool>,
}

/// Describes an instance of an LLM tool call.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolCall {

    /// The ID of the tool call.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// The type of the tool call.
    ///
    /// Currently, only `function` is supported.
    #[serde(rename = "type")]
    pub kind: Option<String>,

    /// The function that the model called.
    pub function: FunctionCall,
}

/// Describes the function called by an associated [ToolCall].
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FunctionCall {

    /// The arguments to call the function with.
    ///
    /// Note that the model does not always generate valid JSON, and
    /// may hallucinate parameters not defined by your function
    /// schema. Validate the arguments in your code before calling
    /// your function.
    pub arguments: serde_json::Value,

    /// The name of the function to call.
    pub name: String,
}
